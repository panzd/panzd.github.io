[{"content":"前言: 前言：其实，现在理解RPC的概念较为简单，但在一个概念在走向成熟的过程中的探索，是值得我们追寻与思考的。要追本溯源，是因为历史总与我们的现在遥遥相和，History doesnot repeat, but it rhymes.\n文章的岁数比我大，来自《ACM Transactions on Computer Systems, Vol. 2, No. 1, February 1984》，是在1976年的前人提出概念上的拓展，最后形成的就是RPC规范，可以说是远程调用的实行的起点，一个真正的开启。\nRemote procedure calls (RPC) appear to be a useful paradig m for providing communication across a network between programs written in a high-level language.\nBackground不谈了，那时候一切都是刚开始。\n环境也不谈了，和现在相差很大，但需要理解PUP协议的内容，应为接下来，会谈到很多次。\nThe PUP family of protocols provides uniform access to any computer onthis internetwork. Previous PUP protocols include simple unreliable (but high-probability) datagram service, and reliable flow-controlled byte streams.\nAims RPC的初衷就是让分布式计算更加方便。在此之前，困难重重，机器、网络、协议、传输路径等等，有点像是带着导航的\u0026quot;漂流瓶\u0026quot;。\nRPC will, we hope, remove unnecessary difficulties, leaving only the fundamental difficulties of building distributed systems: timing, inde-\npendent failure of components, and the coexistence of independent execution environments.\n主要有两个目标，减少困难和避免失败。\nAn important issue in design is resolving the tension between powerful semantics and efficiency.\n虽然当时的主流语言Mesa已经没人记住，但数据结构的规范和响应与返回流程，留了下来。以GRPC协议栈为例。\n我们可以看到基础设计被沿用了下来，没有使用远程调用最开始的共享地址空间的方式，因为它会产生undue upheaval，主要是因为进程的竞争，会有峰谷值的差异，这会在网络环境中开销加大。We discarded the possibility of emulating some form of shared address space among the computers.\n可以看到TCP和Sockets同为协议栈的基石。\nStructure 它的结构是与 Nelson的论文是相似的，包含五个部分，the user, the user-stub, the RPC communications package (known as RPCRuntime), the server-stub, and the server.\n其实现在很容易理解，只是RPCRuntime有了稍许变化，On receipt of these packets, the RPCRuntime in the callee machine passes them to the server-stub.更多是作为Cedar system的标准部分，RPCRuntime is responsible for packet-level communications.\nNaming The binding operation offered by our RPC package is to bind an importer of an interface to an exporter of an interface. After binding, calls made by the importer invoke procedures implemented by the (remote) exporter. 基本上一个接口由它的类型和接口值组成。\n这里加载出口主要是用分布式数据库的角度，就分为个人和组织两种入口。\nGrapevine distributed database的思想还是留了下来，one for each type and one for each instance.\n这段比较有意思，主要是讲述了RPCRuntime中的Exportlnterface和Importlnterface。就是分离了编辑机制和绑定机制。These are the basis of the Mesa (and Cedar) separate compilation and binding mechanism.\nWhen the RPCRuntime on the callee machine receivesa new call packet it uses the index to look up its table of current exports(efficiently), verifies that the unique identifier in the packet matches that in thetable, and passes the call packet to the dispatcher procedure specified in the table.它其实是维护了一个表进行查询匹配。\n他的探讨非常谦虚，讲述了这种模式的重要影响。我们都知道为了避免过多crash发生。Finally, note that this scheme allows calls to be made only on procedures that have been explicitly exported through the RPC mechanism.\nHowever,the result of a call is sufficient acknowledgment that the call packet was received,and a call packet is sufficient to acknowledge the result packet of the previous call made by that process.就是传递和返回的包如何定义序列和方式。\n这里比较关键，讲到它是如何进行连接的建立与维护。\nthat we rely on the unique identifier we introduced when doing remote binding. Without this identifier we would be unable to detect duplicates if a server crashed and then restarted while a caller was still retransmitting a call packet (not very likely, but just plausible). We are also assuming that the call sequence number from an activity does not repeat even if the calling machine is restarted.\n当链接开始的时候，后端也存储了状态信息的关键数量。我们需要确保远程绑定时的标识是唯一的。并且如何调用方重启，同一个活动的调用序列号并不会重复。这种轻量的连接管理在构建大型分布式系统的时候会变得非常重要。这让调用方能意识到caller如果发生crash或者其他严重的连接失败，就能通知到期待中的用户。\n主要思想就是最小化连接的消耗并在服务上维持稳定的状态。\n下面展示了复杂调用的过程。当涉及到多个数据体或者包的时候，如何维持多个会话的连接反应。\nException Handling 关于异常的处理。Our RPC package faithfully emulates this mechanism.\nThe first step in reducing cost is maintaining in each machine a stock of idle server processes willing to handle incoming packets. 关于懒连接该如何处理。\n关于安全 它的时间，正确率这类。\n最后是状态的讨论。\n我们可以看下，现在主流的gRPC和REST的差别。他们都诞生于同一个思想。\n最后，让我们回顾下本文的思想。\nThe techniques for managing transport level connections so as to minimize the communication costs and the state that must be maintained by a server are important in our experience of servers dealing with large numbers of users. Our binding semantics are quite powerful, but conceptually simple for a programmer familiar with single machine binding.\n简单而有力量。simple and powerful.\n这是一个新事物的产生，对世界带来的改变。\n也是指导我们学习和研究的中心思想。\n对世界来说，减枝要比生枝更加有益，也更值得赞扬。\n","date":"2022-07-23T00:00:00Z","permalink":"/p/%E6%8B%A8%E5%9B%9E1984%E7%9C%8Bimplementing-remote-procedure-calls%E5%A6%82%E4%BD%95%E7%9F%B3%E7%A0%B4%E5%A4%A9%E6%83%8A/","title":"拨回1984:看Implementing Remote Procedure Calls如何石破天惊?"},{"content":"前言: 如果你习惯别人帮你烤肉，那你便无法拒绝terraform。便捷是它的利器，普适是它的价值。你唯一要做的，就是确保最终的状态是你想要的。\nInfrastructure as code (IaC)，IaC allows you to build, change, and manage your infrastructurein a safe, consistent and repeatable way by defining resourceconfigurations that you can version, reuse,and share.\nTool for infrastructure provisioning，是Terraform的本质。\n在那么多基础设施供应工具中，脱颖而出，必有Terraform的独到之处。首先是要挑战广为应用的Ansible，其以playbook模式而强大，playbook通过多个task（服务，任务）集合完成一类功能，让远端主机达到预期的状态，它像是一款用shell写的To-do-list工具。而Terraform关心的是配置文件的最终状态，而不是操作流程。\nTerraform的优势是什么？\n适用于多云平台。\nHCL语言更容易理解，也写地更快。Human-Readable~\nTerraform可以在每次你apply之后，追踪到资源的改变。\n每次修改都可以提交，简而言之有版本控制，更加安全。\n只需要定义你最终想要的状态应该是什么，这很重要。\nTerraform\nprovisions,updates, and destroys infrastructure resources such as physical machines, VMs,network switches, containers, and more.\nConfigurations\nare code written for Terraform, using the human-readable HashiCorp Configuration Language (HCL) to describe the desired state of infrastructure resources.\nProviders\nare the plugins that Terraform uses to manage those resources. Every supported service or infrastructure platform has a provider that defines which resources are available and performs API calls to manage those resources.\nModules\nare reusable Terraform configurations that can be called and configured by other configurations. Most modules manage a few closely related resources from a single provider.\nThe Terraform Registry\nmakes it easy to use any provider or module. To use a provider or module from thisregistry, just add it to your configuration; when you run terraform init, Terraform will automatically download everything it needs.\n可以看到，Terraform 由Terraform Core和Terraform Plugins组成。\nTerraform Core reads the configuration and builds the resource dependency graph. Resource dependency graph使得HCL中可以无视资源的顺序写出资源，无论是subnet、route table，还是associations，Terraform可以找出资源的依赖，并将其正确无误地创建。而你要做的是配好ID，然后等待。\nTerraform Plugins (providers and provisioners) bridge Terraform Core and their respective target APIs. Terraform provider plugins implement resources via basic CRUD (create, read, update, and delete) APIs to communicate with third party services.通过第三方服务调用CRUD API，如果以HashiCups为例，它的接口通过REST API，与Ansible一致。\n\u0026ldquo;Terraform-plugin-framework is a module for building Terraform providers. It is built on terraform-plugin-go. It aims to provide as much of the power, predictability, and versatility of terraform-plugin-go as it can while abstracting away implementation details and repetitive, verbose tasks.\u0026rdquo; 而其核心则是tfsdk，tfsdk包让Terraform能够与provider通信。\n可以来看一下代码，我们拿hashicup provider 举例！\nNew方法来调用provider的一个实例\n而provider的struct，较为简单。作为一个api client去请求数据，而不是Terraform直接向api递交请求，如同SDKv2一样。\n我们可以看下具体的providerData，\n而接下来的congfigure方法则api client的配置加入到provider。\nctx context.Context：属于golang标准库的一部分，我们很熟悉，通常用作生成api 请求。\nreq tfsdk.ConfigureProviderRequest：作为配置步骤中的请求，它需要在tfsdk库中的request struct，并且与其他runtime信息一样，会在Terraform configuration block中列举出来。\nresp *tfsdk.ConfigureProviderResponse：注意它是一个指针。作为对请求的响应，还可以返回error和warning。\n下面，我们来看下请求方法的细节，\n从配置中获取provider数据\n2.验证username，password，host的存在。\n3.创建新的api client\n代码都很简单..\n还有很多很多代码，下次再写吧\u0026hellip;..\n进入第二部分，Terraform的使用。\n定义你的基础设施 配置 初始化init，上面很大部分讲的就是初始化的过程 Plan，预览，会告知你对资源的操作 Apply执行 值得注意的是，在plan阶段，\n黄色的波浪线字符是更改modify现有资源 。\n而绿色的加号则是create新资源。\n红色的减号是delete旧资源。\n这边都很简单，就再说一个有趣的概念。\nDate Resource，HCL语言中向服务器查询资源的具体信息，可以让你查询到现有的资源和组件，它有着非常有意思的用法。譬如coffee就作为HashiCups的date resource，\n一杯咖啡，name、price、teaser，似乎还少了拉花\u0026hellip;..\n感谢阅读。\n参考资料：\nhttps://learn.hashicorp.com/terraform?utm_source=terraform_io https://www.terraform.io/internals/graph https://learn.hashicorp.com/ https://github.com/hashicorp/terraform ","date":"2022-05-19T00:00:00Z","permalink":"/p/infrastructure-as-codeterraform%E5%88%B6%E9%9C%B8%E4%B9%8B%E9%81%93/","title":"Infrastructure As Code：Terraform制霸之道"},{"content":"前言 主要是对之前的困惑的地方尝试解答，但并不完全准确，还是需要继续深入理解\n1.map 是否并发安全？ map对象必须在使用之前初始化。如果不初始化就直接赋值的话，会出现panic异常。\nmap的类型是map[key]，key类型必须是可比较的,不能是slice、map和函数值。\nGo语言内建的map对象不是线程安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致panic。\n2.map 循环是有序的还是无序的？ 遍历一个map对象的时候，迭代的元素的顺序是不确定的，无法保证两次遍历的顺序是一样的，也不能保证现在的顺序和插入的顺序一致。\n如果想要按照key的顺序获取map的值，需要先取出所有的key进行排序，然后按照这个排序的key依次获取对应的值。\n而如果想要保证元素有序，比如按照元素插入的顺序进行遍历，可以使用辅助的数据结构，比如orderedmap，来记录插入顺序。\n3.怎么处理对map 进行并发访问？ 加读写锁：扩展map，支持并发读写\n分片加锁：更高效的并发map。尽量减少锁的粒度和锁的持有时间。\n减少锁的粒度常用的方法就是分片（Shard）。由不同的线程去获取。Go知名的分片并发map的实现是orcaman/concurrent-map。它默认采用32个分片。\n4.map 中删除一个 key，它的内存会释放么？ 如果删除的元素是值类型，如int，float，bool，string，数组，struct，map的内存不会自动释放。\n如果删除的元素是引用类型，如指针，slice，map，chan等，map的内存会自动释放，但释放的内存是子元素应用类型的内存占用。\n将map设置为nil后，内存被回收\n5.nil map 和空 map 有何不同？ nil map和空map基本一致，在操作上又不同。\n都可以读取值，但是都是空值。\n空map可以赋值，nil map不可以。\n虽然都是空的，但是也可以使用delete进行删除操作。\n6.nil切片（nil slice）和空切片（empty slice）有什么不同？ 由于slice内置结构存在指针，因此不同的是指针是否被开辟空间。\nnil slice 完全就是空未被初始化，内置指针数组未开辟空间，则 nil slice == nil 成立\nempty slice 可以理解为空数据，已经开辟内存空间，内置指针数组已经开辟空间有指向内存地址，empty slice == nil 不成立，判空需要用\nlen(empty slice) == 0\n7.函数调用需要传入结构体时，传指针还是值？怎么区分什么时候用哪种？ go里面没有引用类型，所有的函数传递都是值传递\n像slice，map，channel由于其内置结构里存在指针，因此传递以上类型会被修改原先数据。\n传值情况：不想改变原来数据，只需要数据进行使用。\n传指针情况：想要改变原来数据或者想要高效率，则传递指针更高效。\n8.Go 如何实现原子操作？ CompareAndSwap(CAS)，go中的Cas操作，是借用了CPU提供的原子性指令来实现，在sync/atomic包中。\n四大操作，Swap(交换)，Add(增加或减少)，Load(原子读取)，Store(原子写入)。\n9.原子操作与互斥锁的区别？ 互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作。\n原子操作是无锁的，常常直接通过CPU指令直接实现。\n原子操作中的CAS趋于乐观锁，CAS操作并不那么容易成功，需要判断，然后尝试处理。\n可以把互斥锁理解为悲观锁，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。\n10.Mutex是悲观锁还是乐观锁？悲观锁、乐观锁是什么？ mutex互斥锁类似悲观锁，总是假设会有并发的操作要修改被操作的值，所以使用锁将相关操作放入到临界区加以保存。\nCAS操作做法趋于乐观锁，总是假设被操作的值未曾改变（即与旧值相等），并一旦确认这个假设的真实性就立即进行值替换。\n在被操作值被频繁变更的情况下，CAS操作并不那么容易成功所以需要不断进行尝试，直到成功为止。\n11.Mutex有几种模式？ 正常模式，锁的等待者会按照先进先出的顺序获取锁。\n一旦Goroutine超过1ms没有获取到锁，它会切换到饥饿模式。\n饥饿模式目的是保证互斥锁的公平性。\n如果一个Goroutine获得了互斥锁并且它在队列末尾或者它等待的时间小于1ms,当前互斥锁就会切换到正常模式。\n正常模式提供了更好的性能，而饥饿模式能避免Goroutine由于陷入等待无法获取锁而造成的高尾延迟。\n12.怎么控制并发数？ WaitGroup位于sync包下，某任务需要多 goroutine 协同工作，每个 goroutine 只能做该任务的一部分，只有全部的 goroutine 都完成，任务才算是完成。\nChannel+Select。定义一个全局变量，在其它地方通过修改这个变量进行通知，后台 goroutine 会不停的检查这个变量，如果发现变量发生了变化，即自行关闭。\nContext：多层级groutine之间的信号传播（包括元数据传播，取消信号传播、超时控制等。依次退出所占的资源。\n13.Go语言中的GC算法的实现？ 标记清除(mark-sweep)算法是最常见的垃圾收集算法。分为mark和sweep\n三色标记法的标记阶段结束后，应用程序的堆中不存在任何灰色对象。\n如果不应该被回收的对象却被回收了，这在内存管理中叫做“悬挂指针”， 即指针没有指向特定类型的合法对象。\n14.GC 的触发时机？ 系统触发：运行时自行根据内置的条件，维护整个应用程序的可用性。\n手动触发：开发者在业务代码中自行调用 runtime.GC 方法来触发 GC 行为\n系统触发主要存在三种场景：\ngcTriggerHeap：当所分配的堆大小达到阈值（由控制器计算的触发堆的大小）时，将会触发。\ngcTriggerTime：当距离上一个 GC 周期的时间超过一定时间时，将会触发。-时间周期以 runtime.forcegcperiod 变量为准，默认 2 分钟。\ngcTriggerCycle：如果没有开启 GC，则启动 GC。\n15.如何优雅的实现一个 goroutine 池？(划重点！！！） 使用goroutine和channel实现一个计算int64随机数各位数和的程序。\n开启一个goroutine循环生成int64类型的随机数，发送到jobChan\n开启24个goroutine从jobChan中取出随机数计算各位数的和，将结果发送到resultChan。\n主goroutine从resultChan取出结果并打印到终端输出\n限制生成个数，有缓冲区：\n16.Goroutine为什么会导致内存泄漏？ 内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。\n我们创建的Goroutine没有在我们预期的时刻关闭，导致Goroutine的数量在服务端一直累积增加，最终影响到服务的性能。\nGoroutine本身的堆栈大小是2KB，我们开启一个新的Goroutine，至少会占用2KB的内存大小。当长时间的累积，数量较大时，比如开启了100万个Goroutine，那么至少就会占用2GB的内存。\nGoroutine中的变量若指向了堆内存区，那么，当该Goroutine未被销毁，系统会认为该部分内存还不能被垃圾回收，那么就可能会占用大量的堆区内存空间。\n17.知道Golang的内存逃逸吗？什么情况下会发生内存逃逸？ Golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它逃逸了，必须在堆上分配。完全可知才能在栈上分配。\n逃逸分析是编译器在静态编译的时候，分析对象的生命周期及引用情况来决定对象内存分配到堆上还是栈上，由于栈内存分配较堆快且栈内存回收较快（无需GC），编译器以此来优化程序性能。在函数中申请一个新的对象：\n如果分配在栈中，则函数执行结束后可自动将内存回收。\n如果分配在堆中，则函数执行结束后可交给GC进行处理。\n逃逸策略：\n如果函数外部没有引用，则优先放到栈中；\r如果函数外部存在引用，则必定放到堆中。 指针逃逸\n栈空间不足逃逸\n动态类型逃逸\n闭包引用对象逃逸\n总结：\n栈上分配内存比在堆上分配内存有更高的效率\r栈上分配的内存不需要GC处理\r堆上分配的内存使用完毕会交给GC处理\n逃逸分析的目的是决定分配地址是栈还是堆\n逃逸分析在编译阶段进行\n18.两数传递指针真的比传值的效率高吗？ 我们知道传递指针可以减少底层值的复制，可以提高效率， 但是如果复制的数据量小，由于指针传递会产生逃逸，则可能会使用堆， 也可能增加 GC 的负担，所以传递指针不一定是高效的。\n19.请简述 Go 是如何分配内存的？ 内存空间包含两个重要的区域：栈（stack）和堆（heap）。\n对于小对象（\u0026lt;=32kb），go runtime首先从,Cache开始，然后是Central，最后Heap。\n对于大对象（\u0026gt;32KB），直接从堆中获取。\nheap:全局根对象。负责向操作系统申请内存,管理由垃圾回收器收回的空闲 span 内存块。\ncentral:从Heap 获取空闲 span,并按需要将其切分成 Object 块。Heap 管理着多个central对象,每个central负责处理一种等级的内存分配需求。\ncache:运行行期,每个 cache 都与某个具体线程相绑定,实现无锁内存分配操作。其内部有个以等级为序号的数组,持有多个切分好的 span 对象。缺少空间时,向等级对应的 central 获取新的 span 即可。\n20.struct结构体能不能比较？ 结构体不可以比较，但是同一类型的结构体的值可以比较是否相等的（不可以比较大小）：\n结构体所有字段的值都相等，两个结构体才相等。\n比较的两个结构体必须是相同类型才可以，也就是说他们字段的顺序、名称、类型、标签都相同才可以。而切片和字典不可以比较。\n参考链接：\nhttps://draveness.me/golang\nhttps://blog.learngoprogramming.com\nhttps://golang.org/doc/faq\nhttps://github.com/golang/go/wiki/Articles\nhttps://golang.org/doc/effective_go.html\n","date":"2022-04-11T00:00:00Z","permalink":"/p/golang%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90%E4%B8%80/","title":"Golang问题解析（一）"},{"content":"本文主要分析了defer在代码里的各种情况，本文先发于掘金论坛上。欢迎关注我的掘金账号：panzd\n1.defer执行顺序 defer关键字的插入顺序时从后向前的，而defer关键字执行是从前向后的，所以后来的defer会优先执行。 当goroutine获取到runtime._defer结构体后，将追加在Goroutine_defer链表的最前面。\n2.defer关键词按值传递 defer函数调用都是传值的，会立即复制函数中的引用的外部参数。\n例题：\n这里f(i)拿到的是i的值。\n同理：\n在这里，前者的defer拿到的是i这个值，而后者defer拿到的是域变量(指针)。\n我在increaseB()加入输出，更能明白：\nprintln拿到的也是值。\n3.defer等于nil的函数 可以看到在defer函数启动后，因为nil发生了panic，但在此之前函数是可以顺利运行的。run()的注册也是没有问题的。\n4.在循环中的defer 通常情况下，我们不在循环体里用defer，除非特殊的要求。\n这里出现了不符合我们预期的结果，在这个循环里的defer函数并没有每次循环都发生打印，而是在整个循环结束后，才开始打印。因为defer调用都被压到defer栈里，等待循环函数结束后出栈。要解决的话，一种是不在循环里放defer，另一种如下：\n在defer函数外面再加一层函数，这里defer函数就会在这层函数结束后调用。\n5.用defer来封装 有时候，我们需要用defer来关闭外部资源，譬如数据库，IO操作等等。\n可以看到defer出现了bug，没有出现断开数据库的连接disconnect，connect()被放在了一边没有运行。\n解决方案如下：\n先让connect()函数运行，然后defer利用它的return操作来关闭数据库。\n当然，我们也可以运用一些go的特性(语法糖),从技术上是相同，但是写法不怎么容易理解。\n与上面的方法相同，第一个()连接到数据库，相当于defer db.connect()， 而第二个()则用来运行disconnect方法，在函数调用后，它会执行关闭操作。原因是defer调用了db.connect()关闭操作的值。\n6.在块中的defer 刚开始你可以期待deferred函数会在一个代码块结束后调用，后来你才发现deferred函数只会在整个函数结束后调用， 因为defer属于函数func而并非是块block。对于for、switch都是如此。\ndefer函数是最后输出的。\n对此，我们可以适用前面在循环里的操作，将其封装。\n7.defer与Scope 让我们定义一个函数，它创建一个deferred函数用来释放资源r。 创建了一个reader用来返回Close过程的error消息，如果Close()方法起作用的话，release()会释放资源。\n但这里的输出却是\u0026quot;nil\u0026quot;，不是我们想的\u0026quot;Close Error\u0026quot;。\n原因是，如果block隐式地用新的err变量替代了原本的err变量，而release()只会返回原本err的值。我们只需仍然使用之前的err，用\u0026quot;=\u0026ldquo;代替掉\u0026rdquo;:=\u0026quot;。就会解决这个问题。\n8.Defer在loop的传参 我们创建一个循环，并用defer输出：\n发现全部都是3，这是因为defer只看到了i循环结束后最新的值，Goruntime是将i的地址捕获了后直接传给了defer。\n解决方法1就是直接把参数传给defer：\nGoruntime在循环中创建了不同的i变量，并且将其保存下来，每个defer即可以看到属于它的i变量。\n解决方法2就是在循环中用新的i变量隐藏原本的i：\n9.Defer在loop的传参 我们在defer函数里用了return语句，但却失效了：\n直接返回了nil，而不是error。\n我们指定一个新值给release()函数的结果，这样defer就不用直接返回值，而是帮助release()返回值。\n10.调用recover() 一般情况下，我们要在defer里面调用recover()。当panic发生的时候，recover()不在defer里面的话，就无法catch掉panic，这时候recover()只会返回nil。\n这时候需要将recover()放到defer里面：\n11.调用defer的顺序出错 发生了panic：\n因为我们没有去检查这个url请求是否正确，当它的地址错误的时候，会生成一个nil值，再调用Body就会发生panic。\n正确的方法要将defer放在一个成功的资源分配后，需要在此之前检查返回结果。\n12.没有对错误进行检查 我们在defer里面写好了清理资源的逻辑，并不代表着这个资源就会毫无问题释放掉，它可能产生了隐式的错误，但我们没有发现有效的error信息。\nf.Close()并没有成功，但返回了error信息，但我们没有意识到。\n正确的写法应该要check一下err，并打印出来：\n亦或是用一个新的结果来返回defer里的error：\n13.defer 释放同一种资源 如果我们用同一个变量来close掉同一种资源两次，会发生一些错误：\n它的问题正是之前循环里发生的一样，这样写，所有defer只能使用到最新的值，只会返回同一种结果。\n只需要为每个defer单独设置变量。\n结束 defer的探索就到此结束，感谢阅读，一起进步。\n参考资料：\nGithub：go-demo\n5 Gotchas of Defer in Go — Part I\n5 More Gotchas of Defer in Go — Part II\n5 More Gotchas of Defer in Go — Part III\nGo 语言设计与实现\n","date":"2022-01-15T00:00:00Z","permalink":"/p/golang-defer%E7%9A%84%E6%8E%A2%E7%B4%A2/","title":"Golang defer的探索"},{"content":" 前言 之前我想在我的服务器上执行一个长时间运行的任务，我使用x \u0026amp;挂在后台，并使用nohup x \u0026amp;请求shell结束后不清理命令，并且为防止父进程结束，又使用了setsid x \u0026amp;置父程序id为1。SSH会话被终止，但我再次连上去时使用jobs并没有出现我之前的程序。\n所幸，我发现了linux上的screen程序，非常好用。\n介绍 \u0026ldquo;Screen or GNU Screen is a terminal multiplexer.\u0026ldquo;也就是说Screen是一款终端复用器。我们可以开始一个screen会话，然后在里面可以打开任意数量的虚拟终端。在Screen中运行的进程将在其窗口不可见时继续运行，即使断开SSH连接。\n至于安装就很简单，在Centos上只需要运行：\nsudo yum install screen\n使用 对于screen你需要命名，以区分你的任务。\nscreen -S session_name\n而使用：\nscreen -ls\n则可以查看screen session的id，以便后面的使用。\n使用：\nscreen -r id\n则重新进入之前创建的session里面。\n具体命令 我们进入screen session后，可以使用 Ctr+a 然后 ？查看screen的命令：\n非常的清晰\n一般我们会使用：\ndetach：ctrl+a d\nkill： ctrl+a k\nhistory： ctrl+a { }\nclear：ctrl+a C\nwindowslist：ctrl+a \u0026quot; 列出所有窗口。\nsplit: ctrl+a S 将当前区域水平分割成两个区域。\nother: ctrl+a ctrl+a 在当前窗口和以前窗口之间切换。\n而0-9在screen里面则可以跳转到session窗口。\nscreen 设置 当screen开始时，它会从/etc/screenrc和~/.screenrc读取它的设置参数。我们可以根据这两个文件更改默认screen设置。\n如果没有~/.screenrc的话，可以创建，用来自定义配置。\n以上就是screen的介绍和使用内容。\n结束 当我们想要kill一个screen的时候，可以直接用这个命令：\nscreen -S session_name -X quit\n此外，深入的学习请点击screen指南\nScreen User’s Manual\n","date":"2022-01-15T00:00:00Z","permalink":"/p/linux-screen/","title":"Linux Screen"},{"content":"在2021年里经历了很多事情，成长了很多，希望2022年的自己能更好！\n2021快乐！ ","date":"2022-01-01T00:00:00Z","permalink":"/p/2021-vlog/","title":"2021 vlog"},{"content":" 前言 在我的惠普电脑蓝屏后, 出现了\u0026quot;Oxc000007b\u0026quot;问题, 提示缺少winload.efi文件,在我查阅资料后, 发现是UEFI的Windows Boot Manager程序读取文件的路径失效了, 上次这台双系统电脑出现这个问题是四年前了。而与之相关的正是bcd文件, 可以找到UEFI模式中所有的启动信息。\n介绍 在官方的解释中, 可以看到\u0026quot;启动配置数据(BCD)文件提供了一个用于描述启动应用程序和启动应用程序设置的存储区。BCDEdit是一个用于管理BCD的命令行工具。它可以用于各种目的，包括创建新存储、修改现有存储和添加引导菜单选项。\u0026quot;\n我们可以在\u0026quot;%WINDIR%\\System32\u0026quot;文件夹中找到bcdedit.exe, 如果是像我一样无法进入系统的话, 则可以在windows开机时,进入系统恢复选项(像我的惠普则是按着F11),再选择进入高级选项, 再进入命令行提示符。\n此时便进入到cmd命令行界面, \u0026ldquo;X:\\Windows\\System32\u0026rdquo;, 在这里输入命令:\nbcdedit /enum all\n意思是在命令行中列出所有的UEFI信息\n实践 在界面中,我们可以看到标识符, 这便是windows启动管理器。\n而在左侧\u0026quot;device\u0026quot;对应着右侧的\u0026quot;partition=C:\u0026quot;, 表面EFI信息存在此windows下的C盘中。\u0026ldquo;path\u0026quot;则对应着路径, \u0026ldquo;default\u0026quot;则是默认的加载项, 对应着windows启动加载器。而下面一串长长的字符则表示从休眠状态中恢复的选项, 并没有用set去改变它的本名。\n通常而言, efi文件的信息都是当前windows系统下的C盘中, 但在我的双系统中则是存在\u0026quot;HarddiskVolume2\u0026quot;中, 这是因为之前装双系统的时候分盘导致的。下面让我们再来看一下,\u0026ldquo;winload.efi\u0026quot;文件存在的路径:\n可以看到winload.efi存放的路径,\u0026ldquo;C:Windows\\system32\u0026quot;。而之前出错的问题也是bootmgr找不到此路径下的winload.efi文件。在这里我们可以用bcdedit.exe来更改device和path。\n让我们来试试将\u0026rdquo;\u0026ldquo;的路径更改为\u0026quot;HarddiskVolume2\u0026rdquo;。关于harddiskVolume的信息, 可以从硬盘信息拿到。\nbcdedit /set {bootmgr} device partition=HarddiskVolume2\n此时,我们看到修改已经完成。\n此时,作为双系统的电脑已经能找到winload.efi文件加载。\n深入 让我们再关注到bcdedit的其他命令:\n这里也是常用命令,包括创建一个新的boot设置数据存储等等。一般用作对efi信息的备份。\n","date":"2021-12-18T00:00:00Z","permalink":"/p/windows%E5%90%AF%E5%8A%A8%E4%B8%AD%E7%9A%84bcd%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/","title":"Windows启动中的BCD文件解析"}]